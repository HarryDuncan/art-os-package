export declare const pointLightInfo = "\n    void getPointLightInfo( PointLight pointLight, GeometricContext geometry, IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n";
export declare const dfgApprox = "vec2 dfgApprox( vec3 normal,  vec3 viewDir, float roughness ) {\n\tfloat dotNV = clamp( dot( normal, viewDir ), 0.0, 1.0 );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}";
export declare const computeMultiScattering = "void computeMultiScattering( vec3 normal, vec3 viewDir,  vec3 specularColor,  float specularF90,  float roughness,  vec3 singleScatter,  vec3 multiScatter ) {\n\tvec2 fab = dfgApprox( normal, viewDir, roughness );\n\tvec3 Fr = specularColor;\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}";
export declare const indirectSpecularPhysical = "\nvoid indirectSpecularPhysical( vec3 radiance, vec3 irradiance, vec3 clearcoatRadiance, GeometricContext geometry, PhysicalMaterial material, ReflectedLight reflectedLight) {\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * 0.3183098861837907;\n\tcomputeMultiScattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering * 0.0;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance * 0.0;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance * 0.0;\n}";
export declare const redirectPhysicalLight = "\n    void redirectPhysicalLight( IncidentLight directLight,  GeometricContext geometry, PhysicalMaterial material, ReflectedLight reflectedLight ) {\n\tfloat dotNL = clamp( dot( geometry.normal, directLight.direction ), 0.0, 1.0 );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directSpecular += irradiance * brdfGgx( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * brdfLambert( material.diffuseColor );\n}\n";
export declare const brdfLambert = " vec3 brdfLambert(vec3 diffuseColor ) {\n\treturn 0.3183098861837907 * diffuseColor;\n}";
export declare const getDistanceAttenuation = "\nfloat getDistanceAttenuation(  float lightDistance,  float cutoffDistance, float decayExponent ) {\n    if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n        return pow( clamp( - lightDistance / cutoffDistance + 1.0, 0.0, 1.0 ), decayExponent );\n    }\n    return 1.0;\n}\n";
export declare const inverseTransformDirection = "vec3 inverseTransformDirection( vec3 dir, mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}";
export declare const shGetIrradianceAt = "\nvec3 shGetIrradianceAt(  vec3 normal,  vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}";
export declare const getLightProbeIrradiance = "\nvec3 getLightProbeIrradiance( vec3 lightProbe[9], vec3 normal , mat4 viewMatrix) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix  );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}";
export declare const getIBLIrradiance = "";
export declare const linearToneMapping = "\n    vec3 linearToneMapping(vec3 color, float toneMappingExposure){\n        return toneMappingExposure * color;\n    }\n";
export declare const indirectDiffusePhysical = "void indirectDiffusePhysical( vec3 irradiance,  GeometricContext geometry, PhysicalMaterial material, ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * brdfLambert( material.diffuseColor );\n}";
export declare const linearTosRGB = "vec4 linearTosRGB( vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
export declare const fSchlickVector = "vec3 fSchlickVector(vec3 f0, float f90, float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * (( 1.0 - fresnel ) + ( f90 * fresnel ));\n}";
export declare const fSchlickFloat = "float fSchlickFloat( float f0, float f90, float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}";
export declare const vGGXSmithCorrelated = "float vGGXSmithCorrelated( float alpha, float dotNL, float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, 1e-6 );\n}";
export declare const brdfGgx = "vec3 brdfGgx( vec3 lightDir,vec3 viewDir, vec3 normal, vec3 f0, float f90, float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = clamp( dot( normal, lightDir ), 0.0, 1.0 );\n\tfloat dotNV = clamp( dot( normal, viewDir ), 0.0, 1.0 );\n\tfloat dotNH = clamp( dot( normal, halfDir ), 0.0, 1.0 );\n\tfloat dotVH = clamp( dot( viewDir, halfDir ), 0.0, 1.0 );\n\tvec3 F = fSchlickVector( f0, f90, dotVH );\n\tfloat V = vGGXSmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = dGGX( alpha, dotNH );\n\treturn F * ( V * D );\n}";
export declare const dGGX = "float dGGX( float alpha, float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn 0.3183098861837907 * a2 / pow2( denom );\n}";
